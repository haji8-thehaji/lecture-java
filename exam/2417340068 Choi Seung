//1//
JVM (Java Virtual Machine)
플랫폼 독립성: JVM은 Java 바이트코드를 실행하는 가상 머신으로, 어떤 플랫폼에서도 동일한 Java 프로그램을 실행할 수 있게 함.
바이트코드 실행: Java 소스 코드는 컴파일을 통해 바이트코드로 변환되며, JVM이 이 바이트코드를 해석하고 실행함.
메모리 관리: JVM은 메모리 관리를 자동으로 처리하여 개발자가 직접 메모리를 할당하거나 해제할 필요가 없음.
스레드 관리: JVM은 멀티스레딩을 지원하여 여러 스레드를 동시에 실행할 수 있도록 관리함.
보안: JVM은 코드 실행을 안전하게 관리하는 여러 보안 기능을 제공합니다. 예를 들어, 바이트코드 검증을 통해 악성 코드를 방지함.
성능 최적화: Just-In-Time (JIT) 컴파일러를 사용하여 자주 호출되는 코드를 네이티브 머신 코드로 컴파일하여 실행 성능을 개선함.

GC (Garbage Collection)
자동 메모리 관리: GC는 사용하지 않는 객체를 자동으로 감지하고 메모리를 해제하여 메모리 누수를 방지함.
여러 알고리즘: Java에서는 여러 가지 GC 알고리즘을 제공합니다. 대표적으로 Mark-and-Sweep, Generational Garbage Collection, G1 GC 등이 있음.
세대 기반 메모리 관리: 대부분의 GC 알고리즘은 객체의 생애 주기를 기반으로 한 세대별 관리 방식을 사용합니다. Young Generation, Old Generation 등으로 나뉘어 성능을 최적화함.
Stop-the-World: GC는 객체를 수집하는 동안 애플리케이션의 실행을 일시 중지하는 "Stop-the-World" 이벤트가 발생할 수 있습니다. 이는 성능에 영향을 줄 수 있지만, 최신 알고리즘은 이를 최소화하려고 노력함.
튜닝 가능성: Java 개발자는 GC의 동작 방식을 튜닝할 수 있는 다양한 옵션을 제공받아, 애플리케이션의 요구에 맞게 성능을 조정할 수 있음.


//2//
Overriding (오버라이딩)
정의: 서브클래스(자식 클래스)가 슈퍼클래스(부모 클래스)의 메서드를 재정의하는 것. 즉, 부모 클래스에서 정의한 메서드를 자식 클래스에서 같은 이름, 매개변수 리스트, 리턴 타입으로 새롭게 구현함.
목적: 자식 클래스에서 부모 클래스의 메서드를 특정한 방식으로 동작하도록 변경할 때 사용됨.
특징:
    부모 클래스의 메서드와 동일한 시그니처(이름, 매개변수, 리턴 타입)를 가져야 함.
    @Override 애노테이션을 사용하여 의도를 명확히 할 수 있음.
    런타임 다형성(다형성의 한 형태)을 통해, 객체의 실제 타입에 따라 적절한 메서드가 호출됨.
요약: 부모 클래스의 메서드를 자식 클래스에서 재정의 (동적 바인딩).

Overloading (오버로딩)
정의: 같은 이름의 메서드를 여러 번 정의하지만, 매개변수의 수나 타입이 다른 경우. 즉, 같은 이름을 가진 메서드가 서로 다른 시그니처(매개변수 리스트)를 갖는 것임.
목적: 같은 기능을 수행하는 메서드가 다양한 형태의 인수를 처리할 수 있도록 함.
특징:
    메서드 이름은 같지만 매개변수의 타입, 수, 순서가 달라야 함.
    리턴 타입이 다르더라도 매개변수 리스트가 같으면 오버로딩으로 간주되지 않음.
    컴파일 타임 다형성(컴파일 시점에 어떤 메서드가 호출될지 결정됨)을 구현함.
요약: 같은 이름의 메서드를 매개변수의 타입이나 수를 달리하여 여러 번 정의 (정적 바인딩).


//3//
List
정의: 순서가 있는 요소의 집합으로, 중복된 값을 허용함.
      요소는 인덱스(0부터 시작)를 통해 접근할 수 있음.
구조: 일반적으로 배열의 형태로 구현되며, 요소들은 순서대로 저장됨.
주요 구현 클래스: ArrayList, LinkedList, Vector 등이 있음.
용도: 순서가 중요한 데이터나 중복된 값을 저장할 때 사용됨.
      Ex) 사용자 입력 목록, 아이템 목록 등.
요약: 순서가 있는 데이터의 집합, 중복 허용. 인덱스를 통해 요소에 접근.

Map
정의: 키-값 쌍의 집합으로, 각 키는 유일해야 하며, 값을 통해 키에 접근함.
      순서가 없거나, 특정 구현에 따라 순서를 유지할 수 있음.
구조: 키와 값이 쌍으로 저장되며, 키를 사용하여 값을 조회함.
주요 구현 클래스:  HashMap, TreeMap, LinkedHashMap 등이 있음.
용도: 고유한 키에 연결된 데이터를 저장하고 검색할 때 사용됨.
      Ex) 사용자 ID와 사용자 정보를 저장하는 경우.
요약: 키-값 쌍의 집합, 키는 유일해야 하며, 값을 통해 키에 접근. 순서가 없거나 특정 구현에 따라 유지.


//web 1//
String
불변(Immutable): String 객체는 한 번 생성되면 변경할 수 없습니다. 문자열을 수정하면 새로운 String 객체가 생성됩니다.
메모리 사용: 문자열 수정 시마다 새로운 객체가 생성되므로, 많은 수의 문자열 수정 작업이 있을 경우 메모리 사용이 비효율적일 수 있습니다.
성능: 문자열이 변경되지 않는 경우에는 성능이 우수하지만, 빈번한 수정 작업에는 적합하지 않습니다.


StringBuffer
가변(Mutable): StringBuffer는 내용을 변경할 수 있는 가변 객체입니다. 문자열을 수정할 때 기존 객체를 그대로 사용합니다.
스레드 안전(Thread-safe): StringBuffer는 여러 스레드에서 동시에 안전하게 사용할 수 있도록 설계되었습니다. 모든 메서드가 synchronized로 구현되어 있습니다.
성능: String보다 문자열 수정이 더 효율적이며, 스레드 안전성을 필요로 하는 경우에 적합합니다.


StringBuilder
가변(Mutable): StringBuilder도 내용을 변경할 수 있는 가변 객체입니다. StringBuffer와 비슷하게 문자열을 수정할 수 있습니다.
비스레드 안전(Not thread-safe): StringBuilder는 스레드 안전성을 고려하지 않으므로, 여러 스레드에서 동시에 접근할 경우 데이터 손상이 발생할 수 있습니다.
성능: StringBuffer보다 성능이 더 우수하며, 단일 스레드 환경에서 문자열을 자주 수정할 경우 적합합니다.

요약
String: 불변, 문자열 수정 시 새로운 객체 생성. 주로 변경이 없는 문자열에 적합.
StringBuffer: 가변, 스레드 안전, 문자열 수정에 효율적. 여러 스레드에서 사용해야 할 때 적합.
StringBuilder: 가변, 비스레드 안전, 성능이 뛰어나며 단일 스레드에서 문자열을 자주 수정할 때 적합.


//web 2//
1. REST의 기본 원칙
자원(Resource): REST에서는 모든 데이터나 기능을 "자원"으로 표현합니다. 자원은 URI(Uniform Resource Identifier)로 식별됩니다. 예를 들어, 사용자 정보는 /users와 같은 URI로 접근할 수 있습니다.

HTTP 메서드 사용: RESTful API는 HTTP 프로토콜의 메서드를 사용하여 자원에 대한 작업을 수행함.
주요 메서드는 다음과 같음:
GET: 자원 조회
POST: 자원 생성
PUT: 자원 수정
DELETE: 자원 삭제

2. 상태 표현
무상태성(Stateless): 각 요청은 독립적이며, 클라이언트의 상태를 서버가 기억하지 않음.
                    모든 정보는 요청에 포함되어야 하며, 서버는 요청을 처리하는 데 필요한 모든 정보를 클라이언트로부터 받아야 함.

3. 표현(Representation)
다양한 표현 방식: 자원은 여러 형식(예: JSON, XML 등)으로 표현될 수 있으며, 클라이언트는 서버와의 상호작용 시 원하는 형식을 지정할 수 있음.
                 일반적으로 JSON이 많이 사용됨.

4. 계층화 시스템
계층화된 아키텍처: RESTful API는 클라이언트가 서버와 직접 상호작용하지 않고도 중간 서버(프록시, 게이트웨이 등)를 통해 요청을 처리할 수 있도록 계층화된 구조를 가짐.
                  이를 통해 보안성과 확장성을 높일 수 있음.

5. 캐시 가능
캐시 지원: RESTful API는 클라이언트가 서버로부터 받은 응답을 캐시할 수 있도록 설계되어 있음.
          이를 통해 반복적인 요청의 성능을 향상시키고 서버의 부하를 줄일 수 있음.

6. HATEOAS (Hypermedia as the Engine of Application State)
하이퍼미디어: RESTful API는 클라이언트가 자원 간의 관계를 탐색할 수 있도록 링크를 제공할 수 있음.
             클라이언트는 응답에서 다른 자원으로 이동할 수 있는 링크를 따라가며 상태를 변화시킬 수 있음.

요약
RESTful API는 자원 기반의 아키텍처로, HTTP 메서드를 통해 클라이언트와 서버 간의 통신을 효율적으로 수행함.
무상태성, 다양한 표현, 계층화된 시스템, 캐시 가능성 등의 특징을 통해 웹 서비스의 표준화와 확장성을 제공함.
RESTful API는 현대 웹 애플리케이션에서 널리 사용되며, 다양한 플랫폼과 언어에서 지원됨.


//web 3//
Call By Value (값에 의한 호출)
정의: 함수가 호출될 때, 실제 인수의 값이 복사되어 매개변수로 전달됨.
      즉, 함수 내에서 매개변수의 변경이 호출한 측의 변수에 영향을 주지 않음.
특징: 메모리에서 값의 복사본이 생성되므로, 함수 내에서 값을 변경하더라도 원래 변수는 영향을 받지 않음.
      기본 데이터 타입(예: int, float, boolean 등)에서 주로 사용됨.

Call By Reference (참조에 의한 호출)
정의: 함수가 호출될 때, 실제 인수의 주소(참조)가 전달됩니다.
      따라서 함수 내에서 매개변수의 변경이 호출한 측의 변수에 영향을 미침.
특징: 객체나 배열과 같은 참조형 데이터 타입에서 사용됨.
      함수 내에서 객체를 수정하면 호출한 측의 객체도 변경됨.
      메모리 사용 측면에서 더 효율적일 수 있습니다. 객체의 복사본을 만들지 않기 때문.

요약
Call By Value: 인수의 값이 복사되어 전달. 원본 데이터는 변경되지 않음. 기본 데이터 타입에서 사용.
Call By Reference: 인수의 참조가 전달. 원본 데이터가 변경될 수 있음. 객체나 배열에서 사용.


//web 4//
1. URL 입력
사용자가 웹 브라우저에 URL(Uniform Resource Locator)을 입력함.
예를 들어, https://www.example.com과 같은 주소를 입력함.

2. DNS 조회
도메인 이름 해석: 브라우저는 URL에 포함된 도메인 이름(예: www.example.com)을 IP 주소로 변환하기 위해 DNS(Domain Name System) 서버에 요청을 보냄.
IP 주소 반환: DNS 서버는 해당 도메인에 대한 IP 주소를 반환함.

3. TCP 연결
TCP 연결 설정: 브라우저는 IP 주소에 대해 TCP(Transmission Control Protocol) 연결을 설정함.
              일반적으로 HTTP(S) 프로토콜은 80번(HTTP) 또는 443번(HTTPS) 포트를 사용함.
3-way handshake: TCP 연결이 설정되기 위해 클라이언트와 서버 간에 3-way handshake가 발생함.

4. HTTP 요청
요청 생성: 브라우저는 서버에 요청을 보내기 위해 HTTP 요청 메시지를 생성함.
          요청에는 메서드(GET, POST 등), URL, 헤더 정보 등이 포함됨.
요청 전송: 생성된 HTTP 요청이 서버로 전송됨.

5. 서버 처리
요청 수신: 서버는 HTTP 요청을 수신하고, 요청의 내용을 분석함.
처리 및 응답 생성: 서버는 요청에 따라 필요한 처리를 수행하고, 클라이언트에 반환할 HTTP 응답 메시지를 생성함.

6. HTTP 응답
응답 전송: 서버는 생성한 HTTP 응답을 클라이언트(브라우저)로 전송함.
          응답에는 상태 코드(200, 404 등), 헤더, 콘텐츠(HTML, JSON 등)가 포함됨.

7. 브라우저 렌더링
응답 수신: 브라우저는 서버로부터 응답을 수신함.
HTML 파싱: HTML 문서를 파싱하고, DOM(Document Object Model)을 생성함.
CSS 스타일 적용: CSS 파일이 링크된 경우, 브라우저는 이를 다운로드하고 스타일을 적용함.
JavaScript 실행: 페이지에서 JavaScript가 있을 경우 이를 실행하여 동적인 콘텐츠를 처리함.
렌더링: 최종적으로 브라우저는 페이지를 렌더링하여 사용자에게 표시함.

8. 추가 요청
리소스 요청: 페이지에 포함된 이미지, 비디오, 스크립트, 스타일시트 등의 추가 리소스에 대한 요청이 발생할 수 있음.
            각 리소스에 대해 위의 과정이 반복됨.

요약
1. URL 입력
2. DNS 조회
3. TCP 연결
4. HTTP 요청
5. 서버 처리
6. HTTP 응답
7. 브라우저 렌더링
8. 추가 요청


//web 5//
VO (Value Object)
정의: VO는 값을 표현하는 객체로, 보통 불변(immutable)으로 설계됨.
      주로 데이터의 상태를 나타내며, 특정 값을 가진 객체를 의미함.
      
특징: VO는 주로 데이터베이스에서 한 레코드의 값을 표현하는 데 사용됨.
      equals()와 hashCode() 메서드를 오버라이드하여 값 비교가 가능하도록 구현됨.


BO (Business Object)
정의: BO는 비즈니스 로직을 수행하는 객체로, 주로 비즈니스 규칙이나 처리를 포함함.

특징: VO와 달리 상태를 가지며, 비즈니스 관련 메서드를 포함할 수 있음.
      BO는 데이터의 유효성 검사 및 비즈니스 규칙을 처리하는 역할을 수행함.


DAO (Data Access Object)
정의: DAO는 데이터베이스와의 상호작용을 담당하는 객체로, CRUD(Create, Read, Update, Delete) 작업을 수행함.

특징: DAO는 데이터베이스 관련 코드(쿼리 등)를 캡슐화하여 비즈니스 로직에서 데이터 접근 방식을 분리함.
      데이터베이스와의 연결, 쿼리 실행 및 결과 반환 등의 기능을 담당함.


DTO (Data Transfer Object)
정의: DTO는 데이터를 전송하기 위한 객체로, 주로 네트워크 또는 프로세스 간의 데이터 전송을 위해 사용됨.

특징: DTO는 데이터의 저장소 역할을 하며, 일반적으로 getter와 setter 메서드를 포함함.
      DTO는 비즈니스 로직을 포함하지 않으며, 단순히 데이터를 전달하는 용도로 사용됨.

요약
VO (Value Object): 불변 객체로, 값을 표현하고 비교를 위해 설계됨.
BO (Business Object): 비즈니스 로직과 규칙을 포함하는 객체.
DAO (Data Access Object): 데이터베이스와의 상호작용을 담당하며 CRUD 작업을 수행.
DTO (Data Transfer Object): 데이터 전송을 위한 객체로, 비즈니스 로직이 없음.


//web 6//
== 연산자
기본 개념: == 연산자는 두 객체가 참조(메모리 주소)가 동일한지를 비교함.
          즉, 두 변수가 같은 객체를 가리키고 있는지를 확인함.
사용 대상: 기본 데이터 타입(예: int, char, boolean)과 객체(참조형 데이터 타입) 모두에서 사용할 수 있음.

equals() 메서드
기본 개념: equals() 메서드는 두 객체의 내용(값)이 동일한지를 비교함.
          객체가 동일한 값을 가지고 있다면 true를 반환함.
사용 대상: 모든 객체에서 사용할 수 있으며, 기본적으로 Object 클래스에서 정의된 메서드임.
          특정 클래스에서 이 메서드를 오버라이드하여 의미를 정의할 수 있음.

요약
==: 두 객체의 참조(메모리 주소)를 비교하여 동일한 객체인지를 확인.
equals(): 두 객체의 내용(값)을 비교하여 동일한지를 확인.
