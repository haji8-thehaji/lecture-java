1. 자바는 절차 지향 언어와 다르게 하나의 기능을 객체형태로 만들어 객체들을 결합하여 하나의 프로그램으로 만든 대표적인 객체 지향 언어다.
   자바는 컴파일 언어인 동시에 인터프리터 언어다.
   자바는 텍스트 소스를 컴파일하여 클래스파일로 만든다음 자바 런타임이 클래스 파일을 인터프리트 하면서 실행된다.
   자바는 jvm에 의해서 실행되기 때문에 어떠한 운영체제라도 독립적으로 자바언어를 사용할 수 있다.
   자바는 개발자가 직접 메모리에 접근할 수 없으며 자바가 직접 관리한다.
   객체 생성시 자동적으로 메모리 영역을 찾아서 할당한다. 또한 사용하지 않는 객체를 제거시켜 준다.
   C언어는 개발자가 직접 코드를 작성해야 했지만 자바는 이러한 작업을 자동으로 해주기 때문에 메모리 관리에 신경쓰지 않아도 된다.
   멀티 쓰레딩을 지원해서 하나의 프로그램 단위가 동일한 쓰레드를 동시에 수행할 수 있다.
   운영체제마다 멀티 쓰레드를 이용하는 API가 다르나 자바의 경우는 자바 API를 사용하기 때문에 쉽게 구현 가능하다.
   객체간의 상호 작용을 정의하기 때문에 필요하지 않는 객체는 생성되지 않고, 필요한 객체만 생성하여 사용한다.
   오류가 발생하면 발생한 오류의 클래스만 수정하면 되므로 전체를 수정할 필요가 없다. 즉 유지보수를 쉽고 빠르게 진행할 수 있다.
   모든 메모리 접근을 자바 시스템이 관리하기 때문에 시스템 붕괴의 우려가 없어 안전하고 강력하다.
   자바는 포인터 개념이 없고 유형 정의가 강고하여 실행 전에 클래스 파일을 이용한 프로그램 검사가 가능하다.

2. 오버라이딩 : 부모 클래스가 가진 메소드의 동작 방법을 하위 클래스가 변경(재정의)하여 우선적으로 사용하는 것이다.
	       오버라이딩은 상속받은 메소드의 내용만 변경하는 것이다.
   오버로딩 : 메소드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것을 의미한다.
	    오버로딩은 기존에 없던 새로운 메서드를 정의하는 것이다.

3. 소프트웨어 디자인 패턴에서 싱글톤 패턴(Singleton pattern)을 따르는 클래스는,
   생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
   이와 같은 디자인 유형을 싱글톤 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.

4. List는 기본적으로 데이터들이 순서대로 저장되며 중복을 허용한다.
   Map은 순서가 보장되지 않고 Key값의 중복은 허용하지 않지만 Value값의 중복은 허용된다.


1. String 객체는 한번 값이 할당되면 그 공간은 변하지 않으며, 이것을 불변성(Immutable) 이라고 한다.
   StringBuffer/StringBuilder 객체는 한번 값이 할당되더라도 한번 더 다른 값이 할당되면 할당된 공간이 변하며, 이것을 가변성(mutable) 이라고 한다.
   StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하여, 멀티스레드 환경에서도 동기화를 지원하지만,
   StringBuilder는 동기화를 보장하지 않는다.

2. Restful API는 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위해 사용하는 인터페이스입니다.
   대부분의 비즈니스 애플리케이션은 다양한 태스크를 수행하기 위해 다른 내부 애플리케이션 및 서드 파티 애플리케이션과 통신해야 합니다.
   예를 들어 월간 급여 명세서를 생성하려면 인보이스 발행을 자동화하고 내부의 근무 시간 기록 애플리케이션과 통신하기 위해 내부 계정 시스템이 데이터를 고객의 뱅킹 시스템과 공유해야 합니다.
   Restful API는 안전하고 신뢰할 수 있으며 효율적인 소프트웨어 통신 표준을 따르므로 이러한 정보 교환을 지원합니다.

3. Call by value는 함수 호출시 값을 넘겨주는 방식이고 Call by reference는 값이 아닌 자신을 공유해서 사용하도록 허용하는 것이다.

   Call by value - 값에 의한 호출방식은 인자로 받은 값을 복사하여 처리를 한다.
                    - 원래 값이 수정되지 않는다.
                    - 변수의 복사본이 전달된다.
                    - 실제 인수가 다른 메모리 위치에 생성된다.

   Call by reference - 참조에 의한 호출방식은 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.
                         - 원래의 값이 수정된다.
                         - 변수 자체가 전달된다.
                         - 실제 인수가 같은 메모리 위치에 생성된다.

4. 웹 사이트를 접속하는 과정
   1 - 브라우저 주소창에 www.naver.com을 입력한다.
   2 - 브라우저가 www.naver.com의 IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인한다.
   3 - 만약 요청한 URL(www.naver.com)의 캐시가 없다면, ISP의 DNS 서버가 DNS 쿼리로 www.naver.com을 호스팅하는 서버의 IP 주소를 찾는다.
   4 - 브라우저가 해당 서버와 TCP 연결을 시작한다.
   5 - 브라우저가 웹서버에 HTTP 요청을 보낸다.
   6 - 서버가 요청을 처리하고 응답을 보낸다.
   7 - 서버가 HTTP 응답을 보낸다.
   8 - 브라우저가 HTML 컨텐츠를 보여준다.

5. VO (Value Object) : 데이터 저장 담당 클래스. DTO와 혼용해서 쓰이지만,
                            VO는 값(Value)을 위해 쓰이는 객체로 불변(read only)의 속성을 가진다.
                            보통 getter의 기능만을 포함한다.

   BO (Business Object) : 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체를 말한다.

   DAO (Data Access Object) : 데이터 사용기능 담당 클래스. DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용한다.
                                      때문에 DB Connection 로직까지 설정되어있는 경우가 많다. DB를 사용해 데이터를 CRUD(조회, 조작)하는 기능을 전담한다.

   DTO (Data Transfer Object) : 데이터 저장 담당 클래스. Controller, Service, View 등 계층간 데이터 교환을 위해 사용되는 객체이다.
                                        로직을 갖지 않는 순수한 데이터 객체이며 getter, setter 메소드만을 포함한다. 가변의 성격을 가진다.

6. ==는 주소값이 같은지 아닌지 비교하는 것이고,
   equals()연산도 내부적으로 주소값을 비교하지만 String클래스에서는 equals()를 재정의해 내용을 비교하게 되어있다.
