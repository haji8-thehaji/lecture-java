## 1. Java의 특징 (JVM, GC)
- **JVM**: 자바 가상 머신의 약자로, 자바 프로그램을 OS에 구애받지 않고 어디서든 작동할 수 있게 해준다.
- **GC**: 가비지 컬렉션의 약자로, 자바에서 사용하지 않는 객체를 자동으로 정리하여 메모리 누수를 방지하는 기능이다.

## 2. 오버라이딩(Overriding)과 오버로딩(Overloading)
- **오버라이딩(Overriding)**: 상속받은 메서드를 자식 클래스에서 재정의하는 것이다.
- **오버로딩(Overloading)**: 같은 이름의 메서드를 매개변수의 타입이나 개수를 다르게 하여 여러 개 정의하는 것이다.

## 3. 싱글톤 패턴
- 인스턴스를 하나만 생성하여 사용하는 디자인 패턴이다. 하나의 객체를 공유해서 사용하기 때문에 메모리를 절약할 수 있지만, 코드 결합도가 높아져 수정 및 관리가 어려워질 수 있다.

## 4. List와 Map의 차이
- **List**: 추가한 순서대로 데이터를 저장하는 방식이다. 중복된 데이터도 저장할 수 있다.
- **Map**: 데이터를 중복되지 않는 고유한 키와 그에 대응하는 값의 쌍으로 저장하는 방식이다. 키는 중복될 수 없지만, 키가 다른 경우엔 중복되는 값을 가질 수 있다. List와 달리 순서는 보장되지 않는다.

## 5. String, StringBuffer, StringBuilder의 차이
- **String**: 객체의 값을 변경할 수 없는 불변 자료형으로, 문자열 수정 시 새로운 객체가 생성된다.
- **StringBuffer**: 버퍼의 크기를 유동적으로 조절하여 객체의 값을 변경할 수 있는 가변 자료형이다. 동기화를 지원하여 여러 스레드가 동시에 객체를 사용할 수 있지만, 상대적으로 느리다.
- **StringBuilder**: StringBuffer와 유사하지만 동기화를 지원하지 않아 싱글 스레드 환경에서만 사용되며 더 빠르다.

## 6. RESTful API
- **RESTful API**는 REST라는 설계 방식을 따르는 API(응용 프로그램 인터페이스)다. 
- REST는 인터넷과 같은 분산 환경에서 효율적이고 안정적인 통신을 가능하게 하기 위한 설계 방식이다.

### < REST의 주요 특징 >
- **일관성 있는 인터페이스**: 명확하고 일관된 규칙을 따르는 인터페이스로, 이해하고 사용하기 쉽다.
- **무상태(stateless)**: 각 요청 간 클라이언트의 상태 정보를 서버에 저장하지 않는다. 모든 요청은 독립적으로 처리된다.
- **계층화 시스템**: 클라이언트는 요청이 직접 서버에 연결된 것인지, 프록시나 게이트웨이를 거친 것인지 알 필요가 없다.
- **캐시 가능성**: 서버 응답은 캐시될 수 있으며, 이를 통해 대량의 요청을 효율적으로 처리한다.
- **온디맨드 코드**: 서버가 클라이언트에 실행할 코드를 전송해 기능을 일시적으로 확장하거나 사용자 지정할 수 있다.
  
  이렇게 RESTful API는 단순하고 직관적인 설계 덕분에 다양한 시스템 간 효율적인 통신을 가능하게 해준다.

## 7. Call By Value와 Call By Reference의 차이
- **Call By Value**: 함수를 호출할 때 변수에 저장된 값의 복사본이 전달된다. 원본 변수의 값은 수정할 수 없다.
- **Call By Reference**: 함수를 호출할 때 변수의 메모리 주소가 전달되며, 원본 변수의 값을 직접 수정할 수 있다.

## 8. 웹에 접속할 때의 과정
1. **URL 입력**: 사용자가 브라우저 주소창에 웹 페이지의 URL을 입력한다.
2. **DNS 조회**: 브라우저가 URL의 도메인 네임을 DNS 서버에 질의해 해당 도메인의 IP 주소를 찾는다.
3. **HTTP 요청 생성 및 전송**: 찾은 IP 주소로 HTTP 요청 메시지를 생성하고 TCP 프로토콜을 통해 서버로 전송한다.
4. **HTTP 요청 처리**: 웹 서버가 요청 메시지를 처리하고 요청된 데이터를 검색한다.
5. **HTTP 응답 생성 및 전송**: 서버가 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 통해 브라우저로 전송한다.
6. **웹 페이지 렌더링**: 브라우저가 응답 메시지를 웹 페이지로 변환해 사용자에게 보여준다.

## 9. VO, BO, DAO, DTO의 차이
- **VO (Value Object)**: 값을 저장하는 객체로, 주로 데이터베이스의 테이블과 매칭되는 데이터를 담는다. 불변 객체로 사용되며, equals()와 hashCode() 메서드를 오버라이드해 객체의 값을 비교한다.
- **BO (Business Object)**: 비즈니스 로직을 처리하는 객체로, 데이터를 계산하고 처리하며 비즈니스 규칙을 적용한다.
- **DAO (Data Access Object)**: 데이터베이스와 상호작용하는 객체로, 데이터의 검색, 삽입, 수정, 삭제 작업을 처리하며 비즈니스 계층이 데이터베이스에 직접 접근하지 않도록 한다.
- **DTO (Data Transfer Object)**: 데이터를 계층 간 또는 네트워크를 통해 전송하기 위한 객체로, 비즈니스 로직 없이 순수하게 데이터 전달에만 집중한다.

## 10. ==와 equals()의 차이
- **"=="**: 두 객체가 같은 메모리 주소를 참조하는지 비교한다. 값이 같더라도 메모리 주소가 다르면 false가 된다.
- **equals()**: 두 객체의 값이 같은지를 비교한다. 메모리 주소가 달라도 값이 같으면 true가 된다.
