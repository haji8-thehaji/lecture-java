1) Java의 특징을 설명해주세요.(JVM, GC)



JVM (Java Virtual Machine)
Java는 플랫폼 독립적인 언어로, JVM을 통해 어느 운영체제에서든 동일한 프로그램을 실행할 수 있습니다. 자바 코드는 컴파일되어 바이트코드로 변환되며, 이 바이트코드는 JVM에서 실행됩니다. JVM은 각 운영체제에 맞게 구현되어 있어, 자바 프로그램이 한 번 작성되면 다양한 환경에서 실행 가능합니다.

GC (Garbage Collection)
Java는 자동 메모리 관리 기능을 제공합니다. **가비지 컬렉터(Garbage Collector, GC)**가 더 이상 사용되지 않는 객체를 자동으로 제거해 메모리 누수를 방지합니다. 이를 통해 개발자는 명시적으로 메모리를 해제할 필요가 없으며, 프로그램이 안정적으로 동작할 수 있습니다. GC는 주기적으로 메모리를 검사하고 사용되지 않는 객체를 회수하여 메모리 공간을 확보합니다.

객체 지향 프로그래밍 (OOP)
Java는 객체 지향 언어로, 프로그램을 객체 단위로 나누어 설계하고 개발합니다. 객체 지향의 핵심 원칙인 캡슐화, 상속, 다형성, 추상화 등을 지원하여, 유지보수성과 재사용성을 높입니다.

플랫폼 독립성
자바의 WORA(Write Once, Run Anywhere) 원칙에 따라, 한 번 작성된 코드는 어떤 플랫폼에서든 수정 없이 실행됩니다. 이것은 JVM 덕분에 가능한데, 컴파일된 바이트코드를 각 운영체제에 맞는 JVM이 해석하여 실행하기 때문입니다.

2) 오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 설명해주세요.


오버라이딩(Overriding)

정의: 상속 관계에서 부모 클래스가 가진 메서드를 자식 클래스에서 재정의하는 것을 의미합니다. 부모 클래스의 메서드를 자식 클래스에서 동일한 이름과 매개변수로 재정의하여 새로운 동작을 구현할 수 있습니다.

조건: 메서드의 이름, 매개변수, 반환 타입이 부모 클래스와 동일해야 하며, 부모 메서드보다 더 넓은 범위의 접근 제어자를 가질 수는 있지만 더 좁게는 할 수 없습니다.

사용 목적: 부모 클래스의 메서드를 다형성을 통해 동적으로 호출하거나, 자식 클래스에서 필요한 방식으로 기능을 재구현할 때 사용합니다.


오버로딩(Overloading)

정의: 같은 클래스 내에서 메서드 이름은 동일하지만 서로 다른 매개변수(타입, 개수, 순서)를 가지는 여러 메서드를 정의하는 것을 의미합니다.

조건: 메서드의 이름은 동일하지만, 매개변수의 타입, 개수, 순서가 달라야 합니다. 반환 타입은 달라도 상관없으나, 반환 타입만 다르고 매개변수가 동일한 경우는 허용되지 않습니다.

사용 목적: 동일한 기능을 하는 메서드를 다양한 형태로 호출할 수 있도록 하여 편의성을 높이기 위해 사용합니다.

3) 싱글톤 패턴에 대해 설명해주세요.

싱글톤 패턴(Singleton Pattern)
싱글톤 패턴은 오직 하나의 인스턴스만을 생성하도록 제한하는 디자인 패턴입니다. 프로그램 내에서 해당 클래스의 객체가 단 하나만 존재하도록 하며, 그 객체에 접근할 수 있는 전역적인 접근 포인트를 제공합니다.

주요 특징
하나의 인스턴스: 클래스의 인스턴스가 하나만 존재하게 하여, 어디서든 동일한 객체를 사용할 수 있습니다.

전역적 접근: 싱글톤 객체는 전역적으로 접근 가능하며, 이를 통해 다른 객체들이 싱글톤 객체를 공유할 수 있습니다.

Lazy Initialization: 필요할 때까지 객체를 생성하지 않고, 최초로 접근할 때 객체를 생성하는 방식입니다. 이를 통해 메모리와 자원을 효율적으로 사용할 수 있습니다.

장점
메모리 절약: 동일한 객체를 여러 번 생성할 필요가 없으므로 메모리를 절약할 수 있습니다.
전역 상태 관리: 하나의 인스턴스를 전역적으로 사용할 수 있어, 프로그램 내에서 상태를 쉽게 관리할 수 있습니다.

단점
멀티스레드 환경 문제: 싱글톤 패턴은 여러 스레드에서 동시에 객체를 생성하려고 할 경우, 여러 개의 인스턴스가 생성될 수 있는 문제점이 있습니다. 이를 방지하기 위해 synchronized 키워드 등을 사용하여 스레드 안전성을 보장해야 합니다.
테스트의 어려움: 전역적인 인스턴스는 의존성 주입 등을 어렵게 만들어, 테스트가 힘들어질 수 있습니다.
싱글톤 패턴은 주로 로그 관리, 데이터베이스 연결, 설정 클래스 등에서 많이 사용됩니다.

4) List와 Map의 차이

1. List
정의: List는 순서가 있는 컬렉션으로, 요소들이 삽입된 순서대로 저장됩니다. 각 요소는 인덱스를 통해 접근할 수 있습니다.
특징:
중복 허용: List는 동일한 값을 여러 번 저장할 수 있습니다.
인덱스 기반 접근: 요소들은 0부터 시작하는 인덱스로 관리되며, 인덱스를 통해 특정 요소에 빠르게 접근할 수 있습니다.
구현체: ArrayList, LinkedList, Vector 등이 있습니다.

2. Map
정의: Map은 키(key)-값(value) 쌍으로 구성된 컬렉션입니다. 각 키는 고유해야 하며, 이를 통해 값에 접근할 수 있습니다.
특징:
중복 키 불허: 동일한 키는 존재할 수 없지만, 값은 중복될 수 있습니다.
키 기반 접근: 키를 통해 값에 접근하며, 특정 키에 대한 값을 빠르게 찾을 수 있습니다.
구현체: HashMap, TreeMap, LinkedHashMap, Hashtable 등이 있습니다.

주요 차이점

구분
List

데이터 구조
순서가 있는 값들의 모음
순서
삽입된 순서대로 유지됨
중복 허용
중복된 요소 허용
접근 방식
인덱스 기반
사용 목적
순차적으로 데이터를 관리하고 접근할 때


Map
키-값 쌍으로 구성
순서를 보장하지 않음 (LinkedHashMap 제외)
중복 불가, 값은 중복 가능
키를 통해 값에 접근
키를 통해 값을 빠르게 검색할 때

  1-1.String, StringBuffer, StringBuilder의 차이를 설명해주세요.

String: 문자열을 수정할 수 없는 불변 객체입니다. 한 번 생성되면 변경할 수 없으며, 변경하려면 새로운 객체를 만들어야 해서 메모리와 성능에 부담을 줄 수 있습니다.

StringBuffer: 문자열을 수정할 수 있는 가변 객체로, 스레드 안전성을 보장합니다. 즉, 여러 스레드가 동시에 작업할 때 안전하게 사용할 수 있지만, 그로 인해 상대적으로 속도가 느립니다.

StringBuilder: StringBuffer와 마찬가지로 가변 객체이지만, 스레드 안전성이 필요 없는 경우 더 빠르게 작동합니다. 단일 스레드 환경에서 사용하기 적합합니다​.STACK ABUSE TRAINING HUB

  1-2 Restful API에 대해 설명해주세요.

RESTful API는 REST(Representational State Transfer) 원칙을 따르는 API입니다. HTTP 메서드(GET, POST, PUT, DELETE)를 사용해 CRUD 작업을 수행하며, 클라이언트와 서버 간에 상태를 유지하지 않는 방식으로 통신합니다. RESTful API는 보통 JSON 또는 XML 형식으로 데이터를 주고받으며, 웹 애플리케이션에서 널리 사용됩니다.



  1-3 Call By Value와 Call By Reference의 차이에 대해 설명해주세요.

Call by Value: 메서드에 값을 전달할 때, 해당 값의 복사본이 전달되므로 원래 변수에는 영향을 주지 않습니다. Java에서는 기본 자료형(primitive type)이 Call by Value 방식으로 전달됩니다.

Call by Reference: 참조를 전달하는 방식으로, 참조된 객체의 값을 메서드에서 수정할 수 있습니다. Java에서 객체는 Call by Reference 방식으로 전달되지만, 실제로는 참조의 복사본이 전달됩니다.

  1-4 그림을 보고 웹에 접속할 때 생기는 과정에 대해 설명해주세요.
웹에 접속하는 과정을 그림을 토대로 설명하자면, 사용자가 웹 페이지를 요청하고 해당 페이지가 표시되는 과정을 단계별로 살펴볼 수 있습니다.

1.사용자 입력: 사용자가 웹 브라우저에 특정 URL을 입력합니다.

2.HTTP 요청: 웹 브라우저가 해당 URL을 HTTP 프로토콜을 통해 서버로 보내기 위한 작업을 시작합니다.

3.DNS 요청: HTTP는 DNS 서버에 도메인 네임을 보냅니다. 이 과정에서 브라우저는 URL의 도메인 네임을 통해 해당 서버의 IP 주소를 요청합니다.

4.DNS 응답: DNS 서버는 요청받은 도메인 네임에 해당하는 IP 주소를 HTTP에게 전달합니다. 이때 IP 주소를 받아야 서버에 정확히 접근할 수 있습니다.

5.TCP 연결: HTTP는 받은 IP 주소를 사용하여 TCP와 연결합니다. 이때 HTTP 요청 메시지를 TCP 프로토콜을 통해 전달하며, TCP는 데이터 전송을 위한 안정적인 연결을 설정합니다.

인터넷을 통한 TCP 통신: 이제 TCP는 네트워크(인터넷)를 통해 요청 메시지를 서버 쪽 TCP로 보냅니다.

6.웹 서버 요청 처리: 서버 쪽에서 TCP로 전달된 HTTP 요청 메시지를 받아 웹 서버가 요청된 URL에 맞는 데이터를 처리합니다.

7.HTTP 응답 준비: 서버는 요청된 웹 페이지 데이터를 준비하고, 그 데이터를 HTTP 응답 메시지로 포장합니다.

8.TCP 연결을 통한 응답: 서버 쪽 TCP는 다시 클라이언트 쪽 TCP로 HTTP 응답 메시지를 인터넷을 통해 보냅니다.

9.클라이언트 측 HTTP 처리: 클라이언트 TCP는 받은 HTTP 응답 메시지를 HTTP로 전달하여 웹 페이지 데이터를 확인합니다.

10.웹 페이지 데이터 전송: HTTP는 웹 페이지 데이터를 웹 브라우저에 전달합니다.

11.웹 페이지 출력: 마지막으로 웹 브라우저는 받은 데이터를 사용자가 볼 수 있는 웹 페이지로 렌더링하여 화면에 출력합니다.

이 전체 과정은 매우 짧은 시간 내에 일어나며, 사용자는 입력한 URL의 웹 페이지를 빠르게 확인할 수 있습니다.

  1-5 VO와 BO, DAO, DTO에 대해 설명해주세요.

VO (Value Object): 불변 객체, 값 중심. 주로 데이터를 표현할 때 사용.
BO (Business Object): 비즈니스 로직을 처리하는 객체.
DAO (Data Access Object): 데이터베이스 접근을 담당하는 객체.
DTO (Data Transfer Object): 데이터를 전송하기 위한 객체, 단순 데이터 전달 역할.
이 객체들은 역할에 따라 계층을 분리해 코드의 가독성, 유지보수성을 높이고, 재사용성을 보장합니다.

1. VO (Value Object)
정의: VO는 주로 읽기 전용 데이터 객체로, 값의 집합을 의미합니다. 데이터를 한 곳에서 다른 곳으로 전달할 때 사용되며, VO는 변경되지 않는 불변 객체(immutable object)로 설계되는 것이 일반적입니다.
특징:
VO는 값의 동일성을 기반으로 비교됩니다. 같은 속성을 가진 두 VO는 동일하다고 간주됩니다.
값이 변하지 않으므로 불변성을 보장합니다.
사용 예: 이름, 주소와 같은 단순한 데이터를 캡슐화하여 전달할 때 사용.

2. BO (Business Object)
정의: BO는 비즈니스 로직을 처리하는 객체입니다. 주로 애플리케이션의 비즈니스 규칙을 구현하고, 데이터를 처리하는 역할을 합니다.
특징:
BO는 데이터와 관련된 비즈니스 규칙을 캡슐화하며, 주로 서비스 레이어에서 사용됩니다.
복잡한 비즈니스 로직이 포함될 수 있습니다.
사용 예: 사용자의 주문 처리, 결제 처리 등 애플리케이션의 핵심 비즈니스 로직을 수행할 때.

3. DAO (Data Access Object)
정의: DAO는 데이터베이스와 상호작용하는 객체로, 데이터베이스에 접근하여 데이터를 조회하거나 삽입, 업데이트, 삭제하는 기능을 제공합니다.
특징:
데이터베이스의 CRUD(Create, Read, Update, Delete) 작업을 처리합니다.
DAO는 데이터 소스와 독립적으로 동작하도록 설계되며, 데이터 액세스 코드와 비즈니스 로직을 분리할 수 있게 해줍니다.
사용 예: 특정 테이블에서 데이터를 조회하거나, 새로운 레코드를 삽입할 때.

4. DTO (Data Transfer Object)
정의: DTO는 데이터 전송을 위한 객체로, 주로 여러 계층 간에 데이터를 전송할 때 사용됩니다. 데이터베이스에서 가져온 데이터를 서비스나 컨트롤러에 전달하거나, 반대로 전달받은 데이터를 데이터베이스에 저장할 때 사용합니다.
특징:
DTO는 간단한 데이터 홀더로, 비즈니스 로직이 없고 단순히 데이터를 전달하는 데 목적이 있습니다.
데이터베이스 엔터티와 다른 형태의 데이터를 전달하기 위해 사용될 수 있습니다.
사용 예: 클라이언트와 서버 사이에서 데이터를 주고받을 때.



  1-6 ==와 equals의 차이점은 무엇입니까?

차이점 요약
==는 메모리 주소(참조)를 비교하며, 객체가 동일한 위치를 가리키는지 확인합니다.
equals()는 객체의 내용을 비교하며, 객체가 의미적으로 동일한지를 확인합니다. equals()는 재정의가 가능해 클래스마다 다르게 동작할 수 있습니다.

1. == 연산자
비교 대상: == 연산자는 참조(레퍼런스) 비교를 합니다. 즉, 두 객체가 동일한 메모리 주소를 참조하고 있는지를 확인합니다.

기본 자료형 비교: 기본 자료형(예: int, float)일 경우에는 ==를 사용해 값을 비교합니다.

객체 비교 시: 두 객체가 동일한 객체인지(같은 메모리 위치를 참조하는지) 확인하는 데 사용됩니다.

2. equals() 메서드
비교 대상: equals()는 객체가 같은 값을 가지고 있는지를 비교합니다. 기본적으로 Object 클래스에서 상속받으며, 객체의 내용을 비교하도록 재정의(Override)될 수 있습니다.

객체 비교 시: equals()는 두 객체가 의미적으로 동일한 값을 가지고 있는지를 확인합니다. 예를 들어, 문자열 비교에서 equals()는 문자열의 내용을 비교합니다.

재정의 가능: 많은 클래스(String, Integer 등)는 equals() 메서드를 재정의하여 객체의 논리적 동등성을 비교하도록 설계되어 있습니다.
