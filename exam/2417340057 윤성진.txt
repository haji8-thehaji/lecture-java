1. Java의 특징
●  JVM (Java Virtual Machine): Java 프로그램은 컴파일 후 바이트코드로 변환되며, 이 바이트코드는 JVM에서 실행됩니다. JVM은 플랫폼 독립성을 제공하여 같은 바이트코드가 다양한 운영 체제에서 실행될 수 있도록 합니다. JVM은 메모리 관리와 예외 처리 등 다양한 기능을 담당합니다.
●  GC (Garbage Collection): Java는 자동 메모리 관리 기능인 가비지 컬렉션을 제공합니다. GC는 더 이상 사용되지 않는 객체를 자동으로 탐지하고 메모리를 해제하여 메모리 누수를 방지합니다. 이를 통해 개발자는 메모리 관리에 대한 부담을 덜 수 있습니다.

2. 오버라이딩(Overriding)과 오버로딩(Overloading)
● 오버라이딩(Overriding): 부모 클래스에서 정의된 메소드를 자식 클래스에서 재정의하는 것입니다. 같은 이름과 매개변수를 가진 메소드를 정의하여 자식 클래스에서 부모 클래스의 기능을 변경할 수 있습니다.
● 오버로딩(Overloading): 같은 이름의 메소드를 매개변수의 타입이나 개수에 따라 여러 번 정의하는 것입니다. 같은 기능을 수행하지만 매개변수에 따라 다른 형태로 동작합니다.

3. 싱글톤 패턴
싱글톤 패턴은 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴입니다. 이 패턴은 애플리케이션 전역에서 공유되는 자원이나 상태를 관리할 때 유용합니다. 주로 인스턴스를 생성하는 메소드를 private으로 설정하고, 정적 메소드를 통해 인스턴스를 제공합니다.

4. List와 Map의 차이
● List: 순서가 있는 컬렉션으로, 중복 요소를 허용합니다. 인덱스를 사용하여 요소에 접근할 수 있습니다. 예: ArrayList, LinkedList.

● Map: 키-값 쌍을 저장하는 컬렉션입니다. 키는 중복될 수 없으며, 값은 중복될 수 있습니다. 각 키는 고유하게 매핑되어 값을 식별합니다. 예: HashMap, TreeMap.

String, StringBuffer, StringBuilder의 차이
● String: 변경 불가능한 객체입니다. 한번 생성된 후 값이 변경될 수 없습니다. 문자열 수정 시 새로운 객체가 생성됩니다.

● StringBuffer: 변경 가능한 객체로, 여러 스레드에서 안전하게 사용할 수 있도록 설계되었습니다. 문자열을 수정할 때 객체를 재사용합니다.

● StringBuilder: 변경 가능한 객체로, 단일 스레드 환경에서 사용됩니다. StringBuffer보다 성능이 좋지만 스레드 안전성을 제공하지 않습니다.




5. Restful API
RESTful API는 Representational State Transfer 원칙을 따르는 웹 API입니다. HTTP 프로토콜을 기반으로 하며, 자원(Resource)을 URI로 표현하고, CRUD(Create, Read, Update, Delete) 작업을 HTTP 메소드(GET, POST, PUT, DELETE)로 수행합니다. RESTful API는 상태 비저장(stateless)이며, 클라이언트와 서버 간의 상호작용을 단순화합니다.

6. Call By Value와 Call By Reference
● Call By Value: 메소드 호출 시 매개변수의 값을 복사하여 전달합니다. 호출된 메소드에서 매개변수 값을 변경해도 원본 데이터에는 영향을 미치지 않습니다.

● Call By Reference: 메소드 호출 시 매개변수의 주소를 전달합니다. 이 경우 메소드 내에서 매개변수를 변경하면 원본 데이터도 영향을 받습니다. Java는 기본적으로 Call By Value 방식을 사용하지만, 객체의 경우 객체의 참조를 전달하는 방식으로 동작합니다.

7. 웹에 접속할 때 생기는 과정
1. **사용자 입력(①)**: 사용자가 웹 브라우저에 접속할 때 웹사이트의 URL을 입력합니다. 예를 들어 `www.google.com`과 동일한 URL을 입력합니다. 
2. **웹 페이지 URL 요청(②)**: 웹 브라우저는 입력된 URL을 기반으로 해당 웹사이트의 서버에 접속하기 위해 DNS(도메인 필러 시스템)에 로그인 이름의 IP 주소를 요청합니다.
3. **도메인 이름 확인 (③)**: DNS 서버는 요청받은 등록 이름을 해당 IP 주소로 변환합니다. 입력 이름(`www.google.com`)을 통해 서버가 어디에서 있는지 확인하는 과정입니다. 
4. **IP 주소를 반환(④)**: DNS 서버는 IP 주소를 웹 브라우저에 반환합니다. 이 IP 주소는 웹 서버의 실제 위치를 확인합니다. 
5. **HTTP 요청 메시지 전송(⑤)**: 웹 브라우저는 해당 IP 주소로 HTTP 요청 메시지를 전송합니다. 이 메시지에는 사용자가 요청한 웹 페이지의 URL이 포함되어 있습니다. 
6. **HTTP 요청 메시지 처리(⑥)**: 웹 서버는 브라우저에서 HTTP 요청 메시지를 처리하고, 요청된 페이지나 수신(URL)을 찾고 있습니다. 
7. ** 웹 페이지 준비 (⑦)**: 웹 서버는 요청된 웹 페이지나 데이터를 준비합니다. 
8. ** 웹 페이지 데이터 전송(⑧)**: 웹 서버는 보호되는 웹 페이지 데이터를 HTTP 응답 메시지에 포함시켜 클라이언트(웹 브라우저)로 다시 보냅니다. 
9. **HTTP 응답 메시지 수신(9)**: 웹 브라우저는 웹 서버로부터 HTTP 응답 메시지를 수신하고, 이 메시지에 포함된 웹 페이지 데이터를 종료합니다. 
10. **HTTP 응답 메시지 확인 (⑩)**: 웹 브라우저는 수신한 데이터를 해석하여 사용자가 요청한 웹 페이지를 표시하기 위해 준비합니다. 
11. ** 웹 페이지 데이터 출력(⑪)**: 웹 브라우저는 자체 데이터를 기반으로 웹 페이지를 표시합니다. 
12. **사용자 인증(⑫)**: 최종적으로 사용자는 요청한 웹 페이지를 표시하는 것을 확인하고, 웹사이트를 사용할 수 있게 됩니다.


8. VO와 BO, DAO, DTO

● VO (Value Object): 불변 객체로, 주로 데이터베이스의 데이터를 표현합니다. 비즈니스 로직이 포함되지 않습니다.

● BO (Business Object): 비즈니스 로직을 포함한 객체로, VO를 조작하거나 처리하는 기능을 갖습니다.

● DAO (Data Access Object): 데이터베이스와의 상호작용을 담당하는 객체입니다. CRUD 작업을 수행하는 메소드를 제공합니다.

● DTO (Data Transfer Object): 데이터 전송을 위해 만들어진 객체로, 여러 필드를 그룹화하여 네트워크를 통해 데이터를 전송하는 데 사용됩니다.

9. ==와 equals의 차이점
● ==: 기본 타입의 값 비교 또는 객체의 참조 비교를 수행합니다. 두 객체가 동일한 메모리 주소를 가리키는지를 판단합니다.

● equals(): 객체의 내용을 비교합니다. 두 객체가 같은 데이터를 가지고 있는지를 판단하며, 클래스에 따라 오버라이딩할 수 있습니다.
이러한 정보가 도움이 되었길 바랍니다! 추가 질문이 있으면 언제든지 말씀해 주세요.